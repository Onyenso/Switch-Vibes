import asyncio
import json
import re
from concurrent.futures import ThreadPoolExecutor
from functools import partial

from shared import constants
from shared.utils import string_similarity, list_similarity
from spotify_to_yt.spotify_to_yt import sp, yt


shared_executor = ThreadPoolExecutor()

class SpotifyToYtService:
    @staticmethod
    def get_spotify_id_from_url(url: str) -> str:
        """
        Extracts the id of a Spotify playlist from its url.
        """
        if not url: return None
        sp_link = re.findall(constants.SP_REGEX, url)
        if not sp_link: return None
        sp_link = sp_link[0][0]
        sp_playlist_id = sp_link.split("playlist/")[1].split("?")[0]
        return sp_playlist_id
    
    @staticmethod
    async def handle_spotify_to_yt(consumer, data):
        url = json.loads(data).get("spotify_playlist_url", None)
        spotify_playlist_id = SpotifyToYtService.get_spotify_id_from_url(url)

        if not spotify_playlist_id:
            await consumer.send(text_data=json.dumps({
                "detail": "Invalid Spotify playlist URL.",
                "code": 400
            }))
            return
        
        print("\n================Searching Spotify========================\n")
        await consumer.send(text_data=json.dumps({"message": "Searching Spotify..."}))
        parsed_playlist = await SpotifyToYtService.parse_yt_playlist(consumer, spotify_playlist_id)

        print("\n================Searching YT Music========================\n")
        await consumer.send(json.dumps({"message": "Searching YT Music..."}))
        yt_music_playlist = await SpotifyToYtService.convert_spotify_to_yt(consumer, parsed_playlist)

        await consumer.send(text_data=json.dumps(yt_music_playlist))
    
    @staticmethod
    async def parse_yt_playlist(consumer, playlist_id: str):
        # Get the first 100 tracks from playlist
        try:
            parsed_playlist_tracks = sp.playlist(
                playlist_id=playlist_id,
                fields="id,name,tracks.items(track(name,duration_ms,artists(name))),tracks.next",
            )
        except Exception as e:
            error_message = "Sorry an error occurred. Please try again soon."
            if "404" in str(e):
                error_message = "The requested playlist could not be found on Spotify."
            await consumer.send(text_data=json.dumps({
                "detail": error_message,
                "code": 404 if "404" in str(e) else 424
            }))
            return

        next = parsed_playlist_tracks["tracks"]["next"]
        offset = 0

        # Get the remaining tracks, 100 at a time, if there's more
        while next is not None:
            offset += 100

            next_tracks = sp.playlist_items(
                playlist_id=playlist_id,
                fields="items(track(name,artists(name),duration_ms)),next",
                offset=offset
            )

            parsed_playlist_tracks["tracks"]["items"].extend(next_tracks["items"])
            next = next_tracks["next"]
            parsed_playlist_tracks["tracks"]["next"] = next

        print("\n================Spotify Done========================\n")
        await consumer.send(text_data=json.dumps({"message": "Spotify Done"}))
        return parsed_playlist_tracks
    
    @staticmethod
    async def convert_spotify_to_yt(consumer, spotify_playlist):
        parsed_yt_playlist = []
        nulls = []
        sp_playlist_name = spotify_playlist["name"]
        sp_tracks = spotify_playlist["tracks"]["items"]

        for sp_track in sp_tracks:
            sp_artists = ""

            for sp_artist in sp_track["track"]["artists"]:
                sp_artists += sp_artist["name"] + " "
                
            sp_artists = sp_artists.strip()
            q = f"{sp_track['track']['name']} {sp_artists}"

            yt_track = await SpotifyToYtService.search_for_yt_track(
                consumer=consumer,
                query=q,
                title=sp_track["track"]["name"],
                artists=[artist['name'].lower() for artist in sp_track["track"]["artists"]],
                duration=int(sp_track["track"]["duration_ms"] / 1000),
                index=sp_tracks.index(sp_track)
            )
        
            parsed_yt_playlist.append(yt_track) if yt_track else nulls.append({
                "title": sp_track['track']["name"],
                "artists": sp_track['track']["artists"]
            })

        print("\n================YT Music Done========================\n")
        await consumer.send(text_data=json.dumps({"message": "YT Music Done"}))

        # Create yt playlist and add tracks
        yt_playlist = yt.create_playlist(
            title=sp_playlist_name,
            description="Generated by Switch Vibes.",
            privacy_status = 'UNLISTED',
            video_ids=[track["yt_id"] for track in parsed_yt_playlist]
        )

        data = {
            "link": f"https://music.youtube.com/playlist?list={yt_playlist}",
            "playlist": parsed_yt_playlist,
            "nulls": nulls,
            "flagged": [
                {"title": track["title"], "artists": track["artists"]} for track in parsed_yt_playlist if track["flag"]
            ]
        }

        print(f"YT Music Playlist: {data['link']}\n")

        if data["nulls"]:
            print(f"\n{len(data['nulls'])} tracks from the playlist were not found on YT Music:\n")
            for track in data["nulls"]:
                print(f"Title: {track['title']}\nArtist: {track['artists']}\n")
            
            print("============================================")
        
        if data["flagged"]:
            print(f"\nThe accuracy of {len(data['flagged'])} track(s) from the new YT Music playlist are low:\n")

            for track in data["flagged"]:
                print(f"Title: {track['title']}\nArtist: {track['artists']}\n")

            print("============================================")

        return data
    
    @staticmethod
    async def search_for_yt_track(consumer, query, title, artists, duration, index):

        correct_track = None
        loop = asyncio.get_event_loop()

        try:
            search_func = partial(yt.search, query=query, filter="songs", limit=5)
            response = await loop.run_in_executor(shared_executor, search_func)

            for yt_track in response:
                yt_track_duration = yt_track["duration_seconds"]
                yt_track_title = yt_track["title"]
                yt_track_artists = [artist["name"].lower() for artist in yt_track["artists"]]
                yt_track_id = yt_track["videoId"]

                correct_artist = bool(
                    (
                        yt_track_artists and artists and string_similarity(yt_track_artists[0], artists[0]) >= 0.4
                    ) or
                    (
                        yt_track_artists and list_similarity(yt_track_artists, artists) >= \
                        (1 / max(len(yt_track_artists), len(artists)))
                    ) or
                    string_similarity(str(yt_track_artists), str(artists)) >= 0.4
                )

                if (correct_artist and abs(yt_track_duration - duration) <= 5):
                    flag = False

                    # If string_similarity between song title from YT and Spotify is less than 0.2 OR
                    # (string similarity between sole artists from YT and Spotify is less than 0.5 and
                    # no similar artist in the list of artists from YT and Spotify)
                    if string_similarity(yt_track_title, title) < 0.2 or \
                    (
                        string_similarity(yt_track_artists[0], artists[0]) <= 0.5 and
                        list_similarity(yt_track_artists, artists) < (1 / max(len(yt_track_artists), len(artists)))
                    ):
                        flag = True
                    
                    correct_track = {
                        "title": yt_track_title,
                        "artists": [artist["name"] for artist in yt_track["artists"]],
                        "duration_seconds": yt_track_duration,
                        "yt_id": yt_track_id,
                        "yt_url": f"https://music.youtube.com/watch?v={yt_track_id}",
                        "flag": flag
                    }
                    break
        except Exception as e:
            await consumer.send(text_data=json.dumps({
                "message": f"Error searching for {query} on Spotify: {str(e)}"
            }))
            return None
        
        if correct_track:
            message = f"{index + 1}) Found {correct_track['title']} on YT Music..."
        else:
            message = f"{index + 1}) Didn't find {query} on YT Music..."

        print(message)
        await consumer.send(text_data=json.dumps({
            "message": message,
            "track": correct_track
        }))

        return correct_track
